{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Structures de données relationnelles : les graphes\n",
    "\n",
    "On rappelle trois implémentations possible de la struture de graphe :  \n",
    "* sous forme de matrice d'adjacence\n",
    "* sous forme de dictionnaire de listes de successeur\n",
    "* sous forme de classe  \n",
    "  \n",
    "On donne le graphe suivant. Ecrire sa matrice d'adjacence et son dictionnaire de listes de successeurs. On peut aussi construire une deuxième liste de successeurs du graphe en considérant qu'il n'est pas pondéré.\n",
    "![Exemple de graphe](http://www.maths-info-lycee.fr/images/graphe_ex_notebook.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "g_mat = []\n",
    "\n",
    "g_suc = {}\n",
    "\n",
    "g_suc_np = {}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La classe graphe est donnée ci-dessous. Créer l'objet correspond au graphe précédent."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Node:\n",
    "    def __init__(self,nom):\n",
    "        self.nom =nom\n",
    "        self.traite = False\n",
    "    def __repr__(self):\n",
    "        return f' {self.nom} '\n",
    "\n",
    "\n",
    "class Edge:\n",
    "    def __init__(self, depart, arrivee, poids):\n",
    "        self.depart = depart\n",
    "        self.arrivee = arrivee\n",
    "        self.poids = poids\n",
    "    def __repr__(self):\n",
    "        return f' ({self.depart},{self.arrivee}, poids {self.poids})'\n",
    "\n",
    "class Graphe:       \n",
    "    def __init__(self, nom, pondere):\n",
    "        self.nom=nom\n",
    "        self.listeNoeuds=[]\n",
    "        self.listeAretes=[]\n",
    "        self.pondere = pondere\n",
    "\n",
    "    def addNode(self,nomNoeud):\n",
    "        # vérifie si le noeud du nom entré existe\n",
    "        for elN in self.listeNoeuds:   \n",
    "            if nomNoeud == elN.nom:\n",
    "                return elN\n",
    "        noeud=Node(nomNoeud)    # sinon le crée\n",
    "        self.listeNoeuds.append(noeud)\n",
    "        return noeud\n",
    "       \n",
    "    def addEdge(self, nomNd1, nomNd2, poids = 1):\n",
    "        # G.addNode(nomNd1) crée le noeud dont le\n",
    "        # nom est passé en paramètre\n",
    "        Nd1=self.addNode(nomNd1)   \n",
    "        Nd2=self.addNode(nomNd2)\n",
    "        for elA in self.listeAretes:\n",
    "            # on vérifie si l'arête est déjà là\n",
    "            if nomNd1 == elA.depart.nom and nomNd2 == elA.arrivee.nom:   \n",
    "                return\n",
    "        arete=Edge(Nd1,Nd2,poids)      # crée une arête entre Nd1 et Nd2\n",
    "        self.listeAretes.append(arete)\n",
    "    \n",
    "    def __repr__(self):\n",
    "        c_s = \"\"\n",
    "        for s in self.listeNoeuds :\n",
    "            c_s = c_s + s.__repr__()\n",
    "        c_a = \"\"\n",
    "        for a in self.listeAretes :\n",
    "            c_a = c_a + a.__repr__() +\"\\n\"\n",
    "        return \"\\nNom : \"+ self.nom + \"\\nSommets : \" + c_s + \"\\nAretes : \\n\" + c_a\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Fonctions de conversion\n",
    "\n",
    "Ecrire les fonctions permettant de passer d'une implémentation à une autre.  \n",
    "Au minimum : de matrice d'adjacence vers liste de successeurs et vice-versa. Si possible, de liste d'adjacence vers objet et vice-versa, puis de matrice d'adjacence vers objet et vice-versa.  \n",
    "On pourra tester le programme avec les exemples précédemment faits."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "def suc2Mat(g_s, pondere = False):\n",
    "    \"\"\"\n",
    "    Convertit le dictionnaires de listes de successeur d'un graphe\n",
    "    en matrice d'adjacence.\n",
    "    @param g_s : dictionnaire de listes de successeurs d'un graphe (orienté ou non)\n",
    "    @param pondere : Booléen vrai si le graphe est pondéré\n",
    "    @return g_m : liste de listes, matrice d'adjacence du graphe\n",
    "    \"\"\"\n",
    "\n",
    "    return(g_m)\n",
    "\n",
    "def mat2Suc(g_m, pondere = False):\n",
    "    \"\"\"\n",
    "    Convertit la martrice d'adjacence d'un graphe\n",
    "    en dictionnaires de listes de successeur.\n",
    "    @param g_m : liste de listes, matrice d'adjacence d'un graphe (orienté ou non)\n",
    "    @param pondere : Booléen vrai si le graphe est pondéré\n",
    "    @return g_s : dictionnaire de listes de successeurs du graphe\n",
    "    \"\"\"\n",
    "\n",
    "    return(g_s)\n",
    "\n",
    "def suc2Obj(g_s, nom, pondere = False):\n",
    "    \"\"\"\n",
    "    Convertit le dictionnaires de listes de successeur d'un graphe\n",
    "    en objet de type Graphe.\n",
    "    @param g_s : dictionnaire de listes de successeurs d'un graphe (orienté ou non)\n",
    "    @param nom : chaine de caractères, nom du graphe\n",
    "    @param pondere : Booléen vrai si le graphe est pondéré\n",
    "    @return g_o : objet de type Graphe\n",
    "    \"\"\"\n",
    "\n",
    "    return g_o\n",
    "\n",
    "def obj2Suc(g_o):\n",
    "    \"\"\"\n",
    "    Convertit un objet de type Graphe en dictionnaires de listes de successeur du graphe\n",
    "    @param g_o : dictionnaire de listes de successeurs d'un graphe (orienté ou non)\n",
    "    @return g_s : dictionnaire de listes de successeurs du graphe\n",
    "    \"\"\"\n",
    "\n",
    "    return g_s\n",
    "\n",
    "def mat2Obj(g_m, nom, pondere = False):\n",
    "    \"\"\"\n",
    "    Convertit le dictionnaires de listes de successeur d'un graphe\n",
    "    en objet de type Graphe.\n",
    "    @param g_m : liste de listes, matrice d'adjacence d'un graphe (orienté ou non)\n",
    "    @param nom : chaine de caractères, nom du graphe\n",
    "    @param pondere : Booléen vrai si le graphe est pondéré\n",
    "    @return g_o : objet de type Graphe\n",
    "    \"\"\"\n",
    "\n",
    "    return g_o\n",
    "\n",
    "def obj2Mat(g_o):\n",
    "    \"\"\"\n",
    "    Convertit un objet de type Graphe en dictionnaires de listes de successeur du graphe\n",
    "    @param g_o : dictionnaire de listes de successeurs d'un graphe (orienté ou non)\n",
    "    @return g_m : mtrice d'adjacence du graphe\n",
    "    \"\"\"\n",
    "\n",
    "    return g_m\n",
    "\"\"\"\n",
    "assert mat2Suc(g_mat, True) == g_suc\n",
    "assert suc2Mat(g_suc, True) == g_mat\n",
    "assert mat2Suc(suc2Mat(g_suc_np)) == g_suc_np\n",
    "print(\"conversion liste de successeurs -> objet\")\n",
    "print(suc2Obj(g_suc, \"g objet\",True))\n",
    "print(\"conversion objet -> listes de successeurs\")\n",
    "print(g_suc)\n",
    "g_s_b = obj2Suc(g_obj)\n",
    "print(g_s_b)\n",
    "#assert g_s_b == g_suc   \n",
    "# regarder la différence entre les deux représentations précédentes\n",
    "print(\"\\nconversion matrice d'adjacence -> objet\")\n",
    "print(mat2Obj(g_mat, \"g objet\",True))\n",
    "print(\"\\nconversion objet -> matrice d'adjacence\")\n",
    "print(g_mat)\n",
    "print(obj2Mat(g_obj))\n",
    "# assert obj2Mat(g_obj) == g_mat\n",
    "# regarder la différence entre les deux représentations précédentes (et constater les limites des assertions)\n",
    "\"\"\"\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Fonctions de parcours\n",
    "Implémenter les algorithmes de parcours en largeur et en profondeur. On utilisera l'implémentation de son choix. Pour ceux qui doutent de l'implémentation à utiliser, privilégiez plutôt celle par listes de successeurs. L'algorithme est plus rapide qu'avec la matrice d'adjacence, et par ailleurs il n'y a pas à gérer l'aspect objet qui peut faire peur.  \n",
    "Pour la structure de pile, on pourra utiliser simplement une liste Python, avec `append`/`pop`pour empiler/dépiler. Pour la structure de file, si possible utilisez la bibliothèque `deque` avec `append`/`popleft` pour enfiler/défiler. En cas d'allergie à cette bibliothèque, utilisez une liste Python et `pop(0)` pour défiler (rappel : c'est beaucoup plus lent). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from collections import deque\n",
    "\n",
    "def dfs(g_s, depart, pondere = False):\n",
    "    \"\"\"\n",
    "    Parcours en profondeur d'un graphe donné sous forme de liste de successeurs\n",
    "    @param g_s : dictionnaire des listes de successeurs du graphe\n",
    "    @param depart : entier, sommet de départ du parcours\n",
    "    @param pondere : Booléen vrai si le graphe est pondéré\n",
    "    @return parkour_p : liste des sommets parcours en profondeur\n",
    "    \"\"\"\n",
    "\n",
    "    return parkour_p\n",
    "\n",
    "def bfs(g_s, depart, pondere = False):\n",
    "    \"\"\"\n",
    "    Parcours en largeur d'un graphe donné sous forme de liste de successeurs\n",
    "    @param g_s : dictionnaire des listes de successeurs du graphe\n",
    "    @param depart : entier, sommet de départ du parcours\n",
    "    @param pondere : Booléen vrai si le graphe est pondéré\n",
    "    @return parkour_l : liste des sommets parcours en profondeur\n",
    "    \"\"\"\n",
    "\n",
    "    return parkour_l\n",
    "\n",
    "print(\"Profondeur\")\n",
    "print(dfs(g_suc, 0, True))\n",
    "print(dfs(g_suc_np, 0))\n",
    "print(\"Largeur\")\n",
    "print(bfs(g_suc, 0, True))\n",
    "print(bfs(g_suc_np, 0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Compléments\n",
    "Pour ceux qui vont vite, programmer la recherche de cycles ainsi que celle d'un chemin entre deux sommets. On se placera dans le cas d'un graphe non pondéré."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def distances_chemin(g_s, depart, arrivee):\n",
    "    \"\"\"\n",
    "    Renvoie les distances entre le sommet de départ et tous les autres sommets,\n",
    "    ainsi qu'un chemin entre deux sommets d'un graphe non pondéré donné sous forme de liste de successeurs. \n",
    "    Ici on utilise le parcours en largeur.\n",
    "    @param g_s : dictionnaire des listes de successeurs du graphe non pondéré\n",
    "    @param depart : entier, sommet de départ du chemin\n",
    "    @param arrivee : entier, sommet d'arrivée du chemin\n",
    "    @return promenade : liste des sommets parcours en profondeur\n",
    "    @return distance : longueur du chemin en nombre d'arêtes\n",
    "    \"\"\"\n",
    "\n",
    "    return distances, promenade\n",
    "\n",
    "def cycle(g_s, depart):\n",
    "    \"\"\"\n",
    "    recherche d'un cycle dans un graphe donné sous forme de liste de successeurs\n",
    "    Basé sur le parcours en profondeur\n",
    "    @param g_s : dictionnaire des listes de successeurs du graphe\n",
    "    @param depart : entier, sommet de départ du parcours\n",
    "    @return : booléen Vrai si le graphe possède au moins un cycle, faux sinon\n",
    "    @return pred : tableau des prédécesseurs (dans le cas où le retour vaut Vrai), None sinon\n",
    "    \"\"\"\n",
    "\n",
    "    return False, None\n",
    "\n",
    "\n",
    "print(distances_chemin(g_suc_np, 0, 4))\n",
    "print(cycle(g_suc_np, 0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Application\n",
    "\n",
    "### Un critère graphe-ique de divisibilité par 7\n",
    "_Source : https://blogdemaths.wordpress.com/2013/02/02/un-critere-visuel-de-divisibilite-par-7/_  \n",
    "  \n",
    "  \n",
    "Le graphe orienté suivant permet de savoir si un nombre $n$ est divisible par 7.\n",
    "![](https://blogdemaths.files.wordpress.com/2013/02/graphe_divisibilite_par_7.png)\n",
    "Il s'utilise comme suit:\n",
    "1. Partir du noeud 0\n",
    "2. Parcourir autant de flèches noires que le premier chiffre de $n$.\n",
    "3. Parcourir une flèche bleue\n",
    "4. S'il reste au moins deux chiffres dans $n$, supprimer le premier et boucler sur 2.\n",
    "5. Le nombre est divisible par 7 si et seulement si le noeud d'arrivée est 0  \n",
    "  \n",
    "Tester cet algorithme à la main avec 437 et 378.  \n",
    "Le programmer (il est indispensable de réfléchir à l'implémentation à utiliser, on rajoutera un arc `0 -> 0`). Le programme renverra la liste des sommets parcourus, et affichera le résultat sous la forme `a->b->...`, puis la conclusion. Tester le programme avec des grands nombres (comme 481466241735205727 ou 23197055899603)    \n",
    "  \n",
    "_Remarque_ : la méthode se généralise. Elle est justifiée [ici](https://blogdemaths.wordpress.com/2013/02/02/un-critere-visuel-de-divisibilite-par-7/). Voici par exemple le graphe pour la divisibilité par 13 :  \n",
    "![](https://blogdemaths.files.wordpress.com/2013/02/graphe_divisibilite_par_13.png?w=640&h=480)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "  \n",
    "<hr style=\"color:black; height:1px />\n",
    "<div style=\"float:left;margin:0 10px 10px 0\" markdown=\"1\" style = \"font-size = \"x-small\">\n",
    "<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><img alt=\"Licence Creative Commons\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" /></a><br />Ce(tte) œuvre est mise à disposition selon les termes de la <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International</a>.\n",
    "\n",
    "frederic.mandon`@`ac-montpellier.fr, Lycée Jean Jaurès - Saint Clément de Rivière - France</div>  "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
